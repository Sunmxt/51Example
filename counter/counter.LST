C51 COMPILER V9.00   COUNTER                                                               12/14/2016 23:56:18 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE COUNTER
OBJECT MODULE PLACED IN counter.OBJ
COMPILER INVOKED BY: D:\Program Files (x86)\Keil\C51\BIN\C51.EXE counter.c BROWSE DEBUG OBJECTEXTEND TABS(2)

line level    source

   1          #include <reg52.h>
   2          
   3          typedef unsigned char uchar;
   4          
   5          typedef struct Timer_Context 
   6          {
   7            unsigned char mode;
   8              #define TIMER_MODE                  0
   9              #define TIMER_SETTING_MODE          1
  10              #define DATA_VIEW_MODE              2
  11            
  12            unsigned int counter_ms;
  13            unsigned int hex_loop;
  14            unsigned char digital[4];
  15            unsigned int loop_counter;
  16            
  17            unsigned int digital_index;
  18            unsigned int record_index;
  19            unsigned int button_counter[4];
  20            
  21            unsigned int flags;
  22              #define RUNNING               0x0001
  23              #define BUTTON_1_DETECTED     0x0002
  24              #define BUTTON_1_DOWN         0x0004
  25              #define BUTTON_1_LONG_PUSH    0x0008
  26              #define BUTTON_1_STATUS_MASK  0x000E
  27          
  28              #define BUTTON_2_DETECTED     0x0010
  29              #define BUTTON_2_DOWN         0x0020
  30              #define BUTTON_2_LONG_PUSH    0x0040
  31              #define BUTTON_2_STATUS_MASK  0x0070
  32              
  33              #define BUTTON_3_DETECTED     0x0080
  34              #define BUTTON_3_DOWN         0x0100
  35              #define BUTTON_3_LONG_PUSH    0x0200
  36              #define BUTTON_3_STATUS_MASK  0x0380
  37              
  38              #define BUTTON_4_DETECTED     0x0400
  39              #define BUTTON_4_DOWN         0x0800
  40              #define BUTTON_4_LONG_PUSH    0x1000
  41              #define BUTTON_4_STATUS_MASK  0x1C00
  42              #define REVERSE               0x2000
  43              #define HEX_FLASH_HIDE        0x4000
  44              
  45            unsigned char flash_times[4];
  46              #define FLASH_HEX_INFINITE    0xFF
  47              
  48            unsigned char record[4][4];
  49          }TimerContext;
  50          
  51          /*
  52          sbit Button1 = P3^5;
  53          sbit Button2 = P3^4;
  54          sbit Button3 = P3^3;
  55          sbit Button4 = P3^2;
C51 COMPILER V9.00   COUNTER                                                               12/14/2016 23:56:18 PAGE 2   

  56          */
  57          
  58          sbit HexDot = P0^7;
  59          
  60          
  61          void on_button1_click(TimerContext *context);
  62          void on_button1_long_push(TimerContext *context);
  63          void on_button2_click(TimerContext *context);
  64          void on_button2_long_push(TimerContext *context);
  65          void on_button3_click(TimerContext *context);
  66          void on_button3_long_push(TimerContext *context);
  67          void on_button4_click(TimerContext *context);
  68          void on_button4_long_push(TimerContext *context);
  69          
  70          uchar code DisplayCode[] =
  71            {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90, 0x88, 0x83, 0xCA, 0xE1, 0x86, 0x8E};
  72          //policy
  73            
  74          void recorder_switch(TimerContext *context ,int backword)
  75          {
  76   1        if(backword)
  77   1        {
  78   2          if(context -> record_index)
  79   2            context -> record_index--;
  80   2          else
  81   2            context -> record_index = 3;
  82   2        }
  83   1        else
  84   1        {
  85   2          context -> record_index++;
  86   2          if(context -> record_index >= 4)
  87   2            context -> record_index = 0;
  88   2        }
  89   1        
  90   1        P1 = ~(1 << context -> record_index);
  91   1      }
  92          
  93          void on_button1_click(TimerContext *context)
  94          {
  95   1        int i;
  96   1        unsigned char tmp;
  97   1        
  98   1        switch(context -> mode)
  99   1        {
 100   2        case TIMER_MODE:
 101   2          context -> flags ^= RUNNING;
 102   2          return;
 103   2        
 104   2        case TIMER_SETTING_MODE:
 105   2          context -> flash_times[0] = 0;
 106   2          context -> flash_times[1] = 0;
 107   2          context -> flash_times[2] = 0;
 108   2          context -> flash_times[3] = 0;
 109   2          context -> flags &= ~HEX_FLASH_HIDE; 
 110   2          context -> loop_counter = 0;
 111   2          break;
 112   2        
 113   2        case DATA_VIEW_MODE:
 114   2          for(i = 0 ; i < 4 ; i++)
 115   2          {
 116   3            tmp = context -> digital[i];
 117   3            context -> digital[i] = context -> record[context -> record_index][i];
C51 COMPILER V9.00   COUNTER                                                               12/14/2016 23:56:18 PAGE 3   

 118   3            context -> record[context -> record_index][i] = tmp;
 119   3          }
 120   2          break;
 121   2        }
 122   1        
 123   1        context -> mode = TIMER_MODE;
 124   1      }
 125          
 126          void on_button1_long_push(TimerContext *context)
 127          {
 128   1        if(context -> mode == TIMER_MODE)
 129   1        {
 130   2          context -> mode = TIMER_SETTING_MODE;
 131   2          context -> flags &= ~RUNNING;
 132   2          context -> digital_index = 0;
 133   2        
 134   2          context -> flash_times[1] = 0;
 135   2          context -> flash_times[2] = 0;
 136   2          context -> flash_times[3] = 0;
 137   2          context -> flash_times[0] = 0xFF;
 138   2          context -> flags |= HEX_FLASH_HIDE;
 139   2          context -> loop_counter = 0;
 140   2        }
 141   1      }
 142          
 143          void on_button2_click(TimerContext *context)
 144          {
 145   1        if(context -> flags & REVERSE && context -> mode != DATA_VIEW_MODE)
 146   1        {
 147   2          context -> digital[0] = 9;
 148   2          context -> digital[1] = 9;
 149   2          context -> digital[2] = 9;
 150   2          context -> digital[3] = 9;
 151   2        }
 152   1        else
 153   1        {
 154   2          context -> digital[0] = 0;
 155   2          context -> digital[1] = 0;
 156   2          context -> digital[2] = 0;
 157   2          context -> digital[3] = 0;
 158   2        }
 159   1      }
 160          
 161          void on_button2_long_push(TimerContext *context)
 162          {
 163   1        int i, j;
 164   1        unsigned char tmp;
 165   1        
 166   1        switch(context -> mode)
 167   1        {
 168   2        case TIMER_MODE:
 169   2          context -> flags ^= REVERSE;
 170   2          context -> flash_times[0] = 1;
 171   2          context -> flash_times[1] = 1;
 172   2          context -> flash_times[2] = 1;
 173   2          context -> flash_times[3] = 1;
 174   2          context -> flags |= HEX_FLASH_HIDE;
 175   2          context -> loop_counter = 0;
 176   2          on_button2_click(context);
 177   2          break;
 178   2        
 179   2        case DATA_VIEW_MODE:
C51 COMPILER V9.00   COUNTER                                                               12/14/2016 23:56:18 PAGE 4   

 180   2          for(i = 0 ; i < 4 ; i++)
 181   2          {
 182   3            tmp = context -> digital[i];
 183   3            context -> digital[i] = context -> record[context -> record_index][i];
 184   3            context -> record[context -> record_index][i] = tmp;
 185   3          }
 186   2          for(i = 0 ; i < 4 ;i++)
 187   2            for(j = 0 ; j < 4 ; j++)
 188   2              context -> record[i][j] = 0;
 189   2          for(i = 0 ; i < 4 ; i++)
 190   2          {
 191   3            tmp = context -> digital[i];
 192   3            context -> digital[i] = context -> record[context -> record_index][i];
 193   3            context -> record[context -> record_index][i] = tmp;
 194   3          }
 195   2          break;
 196   2        }
 197   1      }
 198          
 199          void on_button3_click(TimerContext *context)
 200          {
 201   1        int i;
 202   1        unsigned char tmp;
 203   1        switch(context -> mode)
 204   1        {
 205   2        case TIMER_MODE:
 206   2          for(i = 0 ; i < 4 ; i++)
 207   2            context -> record[context -> record_index][i] = context -> digital[i];
 208   2          recorder_switch(context, 0);
 209   2          break;
 210   2        case TIMER_SETTING_MODE:
 211   2          context -> digital[context -> digital_index]++;
 212   2          if(context -> digital[context -> digital_index] > 9)
 213   2            context -> digital[context -> digital_index] = 0;
 214   2          break;
 215   2        case DATA_VIEW_MODE:
 216   2          for(i = 0 ; i < 4 ; i++)
 217   2          {
 218   3            tmp = context -> digital[i];
 219   3            context -> digital[i] = context -> record[context -> record_index][i];
 220   3            context -> record[context -> record_index][i] = tmp;
 221   3          }
 222   2          recorder_switch(context, 1);
 223   2          for(i = 0 ; i < 4 ; i++)
 224   2          {
 225   3            tmp = context -> digital[i];
 226   3            context -> digital[i] = context -> record[context -> record_index][i];
 227   3            context -> record[context -> record_index][i] = tmp;
 228   3          }
 229   2          break;
 230   2        }
 231   1      }
 232          
 233          void on_button3_long_push(TimerContext *context)
 234          {
 235   1        int i;
 236   1        unsigned char tmp;
 237   1        
 238   1        switch(context -> mode)
 239   1        {
 240   2        case TIMER_MODE:
 241   2          context -> flags &= ~RUNNING;
C51 COMPILER V9.00   COUNTER                                                               12/14/2016 23:56:18 PAGE 5   

 242   2          context -> mode = DATA_VIEW_MODE;
 243   2          for(i = 0 ; i < 4 ; i++)
 244   2          {
 245   3            tmp = context -> digital[i];
 246   3            context -> digital[i] = context -> record[context -> record_index][i];
 247   3            context -> record[context -> record_index][i] = tmp;
 248   3          }
 249   2          break;
 250   2        case TIMER_SETTING_MODE:
 251   2          context -> digital_index++;
 252   2          if(context -> digital_index >= 4)
 253   2            context -> digital_index = 0;
 254   2          for(i = 0 ; i < 4 ; i++)
 255   2            context -> flash_times[i] = 0;
 256   2            context -> flash_times[context -> digital_index] = 0xFF;
 257   2          break;
 258   2        }
 259   1      }
 260          
 261          void on_button4_click(TimerContext *context)
 262          {
 263   1        unsigned char tmp;
 264   1        int i;
 265   1        
 266   1        switch(context -> mode)
 267   1        {
 268   2        case TIMER_MODE:
 269   2          recorder_switch(context, 0);
 270   2          break;
 271   2        case TIMER_SETTING_MODE:
 272   2          if(context -> digital[context -> digital_index])
 273   2            context -> digital[context -> digital_index]--;
 274   2          else
 275   2            context -> digital[context -> digital_index] = 9;
 276   2          break;
 277   2        case DATA_VIEW_MODE:
 278   2          for(i = 0 ; i < 4 ; i++)
 279   2          {
 280   3            tmp = context -> digital[i];
 281   3            context -> digital[i] = context -> record[context -> record_index][i];
 282   3            context -> record[context -> record_index][i] = tmp;
 283   3          }
 284   2          recorder_switch(context, 0);
 285   2          for(i = 0 ; i < 4 ; i++)
 286   2          {
 287   3            tmp = context -> digital[i];
 288   3            context -> digital[i] = context -> record[context -> record_index][i];
 289   3            context -> record[context -> record_index][i] = tmp;
 290   3          }
 291   2          break;
 292   2        }
 293   1      }
 294          
 295          void on_button4_long_push(TimerContext *context)
 296          {
 297   1        int i;
 298   1        if(context -> mode == TIMER_SETTING_MODE)
 299   1        {
 300   2          
 301   2          if(context -> digital_index)
 302   2            context -> digital_index--;
 303   2          else
C51 COMPILER V9.00   COUNTER                                                               12/14/2016 23:56:18 PAGE 6   

 304   2            context -> digital_index = 3;
 305   2          for(i = 0 ; i < 4 ; i++)
 306   2            context -> flash_times[i] = 0;
 307   2            context -> flash_times[context -> digital_index] = 0xFF;
 308   2          
 309   2        }
 310   1      }
 311          
 312          //code
 313          void led_hex_display(TimerContext *context)
 314          { 
 315   1        int i;
 316   1        if(!(context -> loop_counter & 3))
 317   1        {
 318   2          if(context -> loop_counter >= 500)
 319   2          {
 320   3            context -> flags ^= HEX_FLASH_HIDE;
 321   3            if(!(context -> flags & HEX_FLASH_HIDE))
 322   3              for(i = 0 ; i < 4 ; i++)
 323   3                if(context -> flash_times[i] > 0 && context -> flash_times[i] < 0xFF)
 324   3                  context -> flash_times[i]--;
 325   3            context -> loop_counter = 0;
 326   3          }
 327   2          if(context -> flags & HEX_FLASH_HIDE && context -> flash_times[context -> hex_loop])
 328   2            P2 = 0x0F;
 329   2          else
 330   2          {
 331   3            P2 = ~(0x08 >> context -> hex_loop);
 332   3            P0 = DisplayCode[context -> digital[context -> hex_loop]];
 333   3            if(context -> hex_loop == 1)
 334   3              HexDot = 0;
 335   3            else
 336   3              HexDot = 1;
 337   3          }
 338   2          context -> hex_loop ++;
 339   2          if(context -> hex_loop > 3)
 340   2            context -> hex_loop = 0;
 341   2        }
 342   1      }
 343          
 344          void time_count(TimerContext *context)
 345          {
 346   1        unsigned int i;
 347   1        
 348   1        if(context -> flags & RUNNING)
 349   1        {
 350   2          context -> counter_ms += 2;
 351   2          if(context -> counter_ms == 100)
 352   2          {
 353   3            i = 0;
 354   3            do
 355   3            {
 356   4              if(context -> flags & REVERSE)
 357   4              {
 358   5                if(context -> digital[i])
 359   5                {
 360   6                  context -> digital[i]--;
 361   6                  break;
 362   6                }
 363   5                else
 364   5                  context -> digital[i] = 9;
 365   5              }
C51 COMPILER V9.00   COUNTER                                                               12/14/2016 23:56:18 PAGE 7   

 366   4              else
 367   4              {
 368   5                if(context -> digital[i] < 9)
 369   5                {
 370   6                  context -> digital[i]++;
 371   6                  break;
 372   6                }
 373   5                else
 374   5                  context -> digital[i] = 0;
 375   5              }
 376   4              i++;
 377   4            }while(i < 4);
 378   3            
 379   3            context -> counter_ms = 0;
 380   3          }
 381   2        }
 382   1      }
 383          
 384          void check_button_io_p3(TimerContext* Context, char IOMask, int LongPushMask,
 385                                  int DownMask, int DetectedMask,
 386                                  void (*OnButtonClick)(TimerContext *context),
 387                                  void (*OnButtonLongPush)(TimerContext *context),
 388                                  unsigned int *Counter)
 389          {
 390   1        if(!(P3 & IOMask))
 391   1        {
 392   2          if( !(Context -> flags & LongPushMask))
 393   2          {
 394   3            (*Counter) ++;
 395   3            Context -> flags |= DetectedMask;
 396   3            if(Context -> flags & DownMask) {
 397   4              if((*Counter) >= 350)
 398   4              {
 399   5                Context -> flags |= LongPushMask;
 400   5                if(OnButtonLongPush)
 401   5                 OnButtonLongPush(Context);
 402   5              }
 403   4            }
 404   3            else {
 405   4              if((*Counter) >= 10)
 406   4                Context -> flags |= DownMask;
 407   4            }
 408   3          }
 409   2        }
 410   1        else
 411   1        {
 412   2          if(Context -> flags & DetectedMask) {
 413   3            if(Context -> flags & DownMask) {
 414   4              if(!(Context -> flags & LongPushMask))
 415   4                if(OnButtonClick)
 416   4                  OnButtonClick(Context);
 417   4            }
 418   3            Context -> flags &= ~((unsigned int)(LongPushMask | DownMask | DetectedMask));
 419   3            (*Counter) = 0;
 420   3          }     
 421   2        }
 422   1      }
 423          
 424          void main()
 425          {
 426   1        TimerContext context;
 427   1        unsigned int i,j,time_error_fix;
C51 COMPILER V9.00   COUNTER                                                               12/14/2016 23:56:18 PAGE 8   

 428   1        
 429   1        //init
 430   1        time_error_fix = 0;
 431   1        context.mode = TIMER_MODE;
 432   1        context.digital[0] = 0;
 433   1        context.digital[1] = 0;
 434   1        context.digital[2] = 0;
 435   1        context.digital[3] = 0;
 436   1        context.flash_times[0] = 0;
 437   1        context.flash_times[1] = 0;
 438   1        context.flash_times[2] = 0;
 439   1        context.flash_times[3] = 0;
 440   1        context.counter_ms = 0;
 441   1        context.hex_loop = 0;
 442   1        context.flags = 0;
 443   1        context.loop_counter = 0;
 444   1        context.record_index = 0;
 445   1        P1 = ~(1 << context.record_index);
 446   1        for(i = 0 ; i < 4 ;i++)
 447   1          for(j = 0 ; j < 4 ; j++)
 448   1            context.record[i][j] = 0;
 449   1        
 450   1        //initalize inner timer
 451   1        TMOD = 0x01; //Timer 0 mode 1
 452   1        TH0 = 0xF8;
 453   1        TL0 = 0xCC;
 454   1        TF0 = 0;
 455   1        TR0 = 1;
 456   1        
 457   1        while(1) //main_loop
 458   1        {
 459   2          if(TF0 == 1)
 460   2          {
 461   3            TF0 = 0;                  
 462   3            
 463   3            i = 0xCB + 10; //fix time error caused by instructions
 464   3            //1ms shou4e be 1843.2 Tick in 11.0592MHZ. 
 465   3            //Each 10 tick should be less 8 ticks to fix the error.
 466   3            time_error_fix ++;
 467   3            if(time_error_fix == 10)
 468   3            {
 469   4              time_error_fix = 0;
 470   4              i += 8;
 471   4            }
 472   3            i += TL0;
 473   3            TL0 = i & 0xFF;
 474   3            TH0 += 0xF8 + (i >> 8);
 475   3            
 476   3            context.loop_counter += 2;
 477   3            led_hex_display(&context);
 478   3            
 479   3            check_button_io_p3(&context, 0x20, BUTTON_1_LONG_PUSH, BUTTON_1_DOWN, BUTTON_1_DETECTED, on_button1_
             -click, on_button1_long_push, &context.button_counter[0]);
 480   3            check_button_io_p3(&context, 0x10, BUTTON_2_LONG_PUSH, BUTTON_2_DOWN, BUTTON_2_DETECTED, on_button2_
             -click, on_button2_long_push, &context.button_counter[1]);
 481   3            check_button_io_p3(&context, 0x08, BUTTON_3_LONG_PUSH, BUTTON_3_DOWN, BUTTON_3_DETECTED, on_button3_
             -click, on_button3_long_push, &context.button_counter[2]);
 482   3            check_button_io_p3(&context, 0x04, BUTTON_4_LONG_PUSH, BUTTON_4_DOWN, BUTTON_4_DETECTED, on_button4_
             -click, on_button4_long_push, &context.button_counter[3]);
 483   3            
 484   3            time_count(&context);
 485   3          }
C51 COMPILER V9.00   COUNTER                                                               12/14/2016 23:56:18 PAGE 9   

 486   2        }
 487   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3741    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----     104
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
