C51 COMPILER V9.00   PWM_MOTO                                                              03/24/2017 21:47:36 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE PWM_MOTO
OBJECT MODULE PLACED IN pwm_moto.OBJ
COMPILER INVOKED BY: E:\Program Files (x86)\Keil\C51\BIN\C51.EXE pwm_moto.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <reg52.h>
   2          #include <intrins.h>
   3          #include "utils.h"
   4            
   5          //LED Indicator
   6          sbit LED0 = P1^0;
   7          sbit LED1 = P1^1;
   8          sbit LED2 = P1^2;
   9          sbit LED3 = P1^3;
  10          sbit LED4 = P1^4;
  11          sbit LED5 = P1^5;
  12          sbit LED6 = P1^6;
  13          sbit LED7 = P1^7;
  14          
  15          
  16          //PWM Pin
  17          sbit PWM0 = P2^0;
  18          sbit PWM1 = P2^1;
  19          sbit PWM2 = P2^2;
  20          sbit PWM3 = P2^3;
  21          PWMPinContext PWMPin[4];
  22          
  23          
  24          //Buttons
  25          sbit BUTTON1 = P3^5;
  26          sbit BUTTON2 = P3^4;
  27          
  28          ButtonContext ButtonContext2;
  29          ButtonContext ButtonContext1;
  30          
  31          
  32          
  33          
  34          
  35          
  36          
  37          //Control values
  38          #define THRUST_BASE     128
  39          
  40          uchar Thrust;                     
  41          int Turn;                        //direction turn value, Left(Negative) Right(Positive)
  42          
  43          
  44          
  45          
  46          bit button1_read(void)
  47          {
  48   1          return BUTTON1;
  49   1      }
  50          
  51          bit button2_read(void)
  52          {
  53   1          return BUTTON2;
  54   1      }
  55          
C51 COMPILER V9.00   PWM_MOTO                                                              03/24/2017 21:47:36 PAGE 2   

  56          
  57          void button_process()
  58          {
  59   1          CheckButton(&ButtonContext1, button1_read, 1, 50, 255);
  60   1          if(ButtonContext1.status & BUTTON_CLICKED)
  61   1          {
  62   2              PWMPin[0].high_width += 8;
  63   2              PWMPin[1].high_width += 8;
  64   2              PWMPin[2].high_width += 8;
  65   2              PWMPin[3].high_width += 8;
  66   2          }
  67   1          CLEAR_BUTTON_MESSAGE(ButtonContext1, BUTTON_MESSAGE_MASK);
  68   1          
  69   1          
  70   1          CheckButton(&ButtonContext2, button2_read, 1, 50, 255);
  71   1          if(ButtonContext2.status & BUTTON_CLICKED)
  72   1          {
  73   2              PWMPin[0].high_width -= 8;
  74   2              PWMPin[1].high_width -= 8;
  75   2              PWMPin[2].high_width -= 8;
  76   2              PWMPin[3].high_width -= 8;
  77   2          }
  78   1          CLEAR_BUTTON_MESSAGE(ButtonContext2, BUTTON_MESSAGE_MASK);
  79   1      }
  80          
  81          void timer0_process() interrupt 1
  82          {
  83   1          TH0 = 0xFC;
  84   1          TL0 = 0x66;
  85   1          
  86   1          button_process();
  87   1      }
  88          
  89          
  90          void timer1_process() interrupt 3
  91          {
  92   1          PWMPin[0].high_width = Thrust + Turn;
  93   1          PWMPin[1].high_width = Thrust + Turn;
  94   1          PWMPin[2].high_width = Thrust - Turn;
  95   1          PWMPin[3].high_width = Thrust - Turn;
  96   1          
  97   1          PWM0 = PWMControl(PWMPin, 1);
  98   1          PWM1 = PWMControl(PWMPin + 1, 1);
  99   1          PWM2 = PWMControl(PWMPin + 2, 1);
 100   1          PWM3 = PWMControl(PWMPin + 3, 1);
 101   1      }
 102          void init()
 103          {
 104   1          //PWM Initialize
 105   1          PWM0 = 0;
 106   1          PWM1 = 0;
 107   1          PWM2 = 0;
 108   1          PWM3 = 0;
 109   1          
 110   1          Turn = 0;
 111   1          
 112   1          PWMPin[0].high_width = Thrust;
 113   1          PWMPin[1].high_width = Thrust;
 114   1          PWMPin[2].high_width = Thrust;
 115   1          PWMPin[3].high_width = Thrust;
 116   1          
 117   1          PWMPin[0].counter = 0;
C51 COMPILER V9.00   PWM_MOTO                                                              03/24/2017 21:47:36 PAGE 3   

 118   1          PWMPin[1].counter = 0;
 119   1          PWMPin[2].counter = 0;
 120   1          PWMPin[3].counter = 0;
 121   1          
 122   1          
 123   1          
 124   1          TMOD = 0x21;                //Timer0 for PWM signal generating
 125   1          TH1 = 0xA3;                 //0.1ms
 126   1          TL1 = 0xA3;
 127   1          
 128   1          TH0 = 0xFC;                 //Timer1 for button checking
 129   1          TL0 = 0x66;
 130   1          
 131   1          TR0 = 1;
 132   1          TR1 = 1;
 133   1          
 134   1          //Interrupt
 135   1          ET0 = 1;
 136   1          ET1 = 1;
 137   1          EA = 1;
 138   1      }
 139          
 140          void main()
 141          {   
 142   1          init();
 143   1          
 144   1          while(1)
 145   1              _nop_();
 146   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    380    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     15    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
